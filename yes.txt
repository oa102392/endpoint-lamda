This diagram illustrates the cloud architecture for the Spaceflake application, showcasing how unique UUIDs are generated and managed across multiple pods within a Kubernetes StatefulSet.

Client: The entry point for API requests that require unique UUIDs.

Ingress Controller / Load Balancer (nginx): Balances incoming API requests across multiple StatefulSet pods, ensuring even distribution of load.

StatefulSet Pods: Each pod (spaceflake-statefulset-0, spaceflake-statefulset-1, spaceflake-statefulset-2) is responsible for generating unique UUIDs.

Node: Represents a single server or instance within the pod.
Session Generator: Manages the generation of UUIDs, cycling through sequence numbers from 0 to 4095.
Workers: Each pod contains 32 workers (worker 0 to worker 31). Each worker can generate up to 4095 unique UUIDs within a millisecond. When the sequence number and worker count reach their limits, the session generator waits for the next millisecond to continue.
UUID Generation Capacity: Each pod can generate 131,072 unique UUIDs every millisecond (32 workers x 4096 sequences).

StatefulSet: A Kubernetes workload API object used to manage stateful applications. Unlike Deployments, StatefulSets maintain a sticky identity for each of their pods. These pods are created from the same specification but are not interchangeable: each has a persistent identifier that it maintains across any rescheduling.

Why StatefulSet: StatefulSets are used instead of Deployments to ensure that each pod has a unique and persistent identity, which is crucial for the Spaceflake application's node ID assignment. This uniqueness allows the system to scale horizontally while maintaining unique identification across nodes and preventing ID conflicts.
This architecture ensures high availability and scalability of the Spaceflake service, allowing it to handle a large number of requests efficiently.